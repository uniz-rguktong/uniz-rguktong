name: Vercel Production Deployment

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }} # Fallback if needed

jobs:
  Deploy-Monorepo:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Dependencies
        run: npm ci

      - name: Build All Workspaces
        run: npx turbo run build

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Deploy Auth Service
        env:
          PROJECT_NAME: uniz-auth-service
        run: |
          vercel link --project $PROJECT_NAME --scope $VERCEL_ORG_ID --token $VERCEL_TOKEN --yes
          vercel deploy --prod --prebuilt --scope $VERCEL_ORG_ID --token $VERCEL_TOKEN

      # Note: Vercel CLI currently doesn't support a single command to deploy all monorepo apps at once 
      # without iterating or using Vercel Git integration.
      # To keep it "boring" and explicit like the previous loop but without the hacks, 
      # we will iterate through the services.
      
      # However, strictly following the request for "vercel deploy --prod", 
      # we need to be mindful that running `vercel deploy` at root deploys the ROOT project.
      # To deploy specific apps, we must target them.
      
      # The cleanest way without "cd hacking" is to use the Vercel CLI to target each project 
      # but let it resolve from the root context or prebuilt artifacts.
      
      # Since we ran `turbo run build`, we have artifacts. 
      # But Vercel CLI needs to map those artifacts to deployments.
      
      # Strategy:
      # We will rely on Vercel's standard monorepo support.
      # Since we fixed the workspace structure, we can simply loop and deploy.
      # The critical difference is NO `npm install` or `cp` inside the loop.
      
  Deploy-Service:
    needs: Deploy-Monorepo # Actually, we can just do it in one job or a matrix
    if: false # Disabling this block to write the cleaner Matrix version below

  # REAL PIPELINE
  Deploy-Matrix:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service: [auth, user, outpass, academics, files, mail, notification, cron, web]
        include:
          - service: gateway
            project_name: uniz-production-gateway
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      
      - name: Install Dependencies
        run: npm ci
        
      - name: Build Project
        # We build EVERYTHING first to ensure shared libs are ready
        run: npx turbo run build --filter=uniz-${{ matrix.service }}-service... --filter=${{ matrix.project_name }}...
        
      - name: Deploy ${{ matrix.service }}
        env:
          PROJECT_NAME: ${{ matrix.project_name || format('uniz-{0}-service', matrix.service) }}
          ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
        run: |
          # Link the project
          npx vercel link --project $PROJECT_NAME --scope $ORG_ID --token $VERCEL_TOKEN --yes
          
          # Pull env vars (needed for some build steps if we weren't prebuilding, but good for safety)
          npx vercel pull --yes --environment=production --scope $ORG_ID --token $VERCEL_TOKEN
          
          # Deploy using Vercel's build (now that structure is correct) OR prebuilt.
          # Since we fixed workspaces, "vercel build" from root targetting the app should work.
          
          # We use --prebuilt to skip the remote build queue and use our verified CI build
          npx vercel build --prod --scope $ORG_ID --token $VERCEL_TOKEN
          npx vercel deploy --prebuilt --prod --scope $ORG_ID --token $VERCEL_TOKEN
